/*
 * @ASCK
 */
#pragma once
#include <systemc.h>

// 指令寄存器
SC_MODULE(IR) {
  sc_in<sc_uint<14>> addr;   // 输入端口，用于接收14位无符号整数地址
  sc_out<sc_uint<20>> inst;  // 输出端口，用于输出20位无符号整数指令

  /*
  ** 模块全局变量
  */

  sc_uint<20> mem[819];  // 指令存储器，共819行，每行存储20位，总共约16KB

  int instNum = 50;  // 指令数量为50条

  // 初始化指令数组
  sc_uint<20> instruction[50] = {
      // 每条指令以二进制形式注释，前缀0b表示二进制数
      0b00000000000000000000,  // 0：空指令
      0b00100000000000000111,  // 1：传送指令 (r0 <- 7): 7
      0b00010010010000000000,  // 2：增加指令 (r1++): 1

      // 以下为为实现正确的寄存器数据而设置的暂停指令 - 减法
      0b11110000000000000000,  // 3-5：暂停指令
      0b11110000000000000000,
      0b11110000000000000000,

      0b00000110000010000010,  // 6：减法指令 (r3 <- r0 - r1): 6

      0b11110000000000000000,  // 7-9：暂停指令
      0b11110000000000000000,
      0b11110000000000000000,

      0b00011000110010000001,  // 10：加法带进位指令 (r4 <- r3 + r1 + 1): 8

      0b11110000000000000000,  // 11-13：暂停指令
      0b11110000000000000000,
      0b11110000000000000000,

      0b00001001000000101001,  // 14：右移指令 (r4 >> 2): 2

      0b01010000000000000101,  // 15：存储指令 (mem[5] <= r0) : 7
      0b01001010000000000101,  // 16：加载指令 (r5 <= mem[5]) : 7

      0b01100000000000000000,  // 17：执行加速器指令

      0b01000100000000010100,  // 18：加载指令 (r2 <= mem[20]) : 17 => 0x11

      0b11110000000000000000,  // 19-24：空指令 (nop)
      0b11110000000000000000,
      0b11110000000000000000,
      0b11110000000000000000,
      0b11110000000000000000,
      0b11110000000000000000};

  SC_CTOR(IR) {
    SC_METHOD(process);  // 注册进程方法process
    sensitive << addr;   // 当addr信号发生变化时触发process方法
    // 将指令数组复制到指令存储器的前instNum行
    for (int i = 0; i < instNum; i++) {
      mem[i] = instruction[i];
    }
    // 将剩余的行填充为nop指令
    for (int i = instNum; i < 819; i++) {
      mem[i] = 0b11110000000000000000;
    }
  }

  void process() {
    if (addr.read() < 819) {         // 如果地址小于819
      inst.write(mem[addr.read()]);  // 输出指令存储器中对应地址的指令
    } else {
      inst.write(0);  // 否则输出空指令
    }
  }
};
